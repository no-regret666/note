# 主从复制

## 第一次同步

主从服务器间的第一次同步的过程可分为三个阶段：

- 第一阶段是建立链接、协商同步
- 第二阶段是主服务器同步数据给从服务器
- 第三阶段是主服务器发送新写命令给从服务器

<img src="https://cdn.xiaolincoding.com//mysql/other/ea4f7e86baf2435af3999e5cd38b6a26.png" alt="图片" style="zoom:67%;" />

**第一阶段：**

`psync`命令表示要进行数据同步。

- `runID`：主服务器ID
- `offset`：复制的进度

`FULLRESYNC`意图采用**全量复制**的方式。

**第二阶段：**

主服务器异步生成RDB文件发送给从服务器，从服务器清空当前数据，载入RDB文件。

主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里：

- 主服务器生成 RDB 文件期间；
- 主服务器发送 RDB 文件给从服务器期间；
- 「从服务器」加载 RDB 文件期间；

**第三阶段：**

主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行。



## 命令传播

主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。主服务器通过这个连接将写操作命令传播给从服务器，从服务器执行。

这个链接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。

上面的这个过程被称为**基于长连接的命令传播**。



## 分摊主服务器的压力

主服务器刚开始与从服务进行数据同步的过程中，由于`bgsave`命令需要使用fork()创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；

传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。

为了解决这个问题，Redis把拥有从服务器的从服务器当作经理角色，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器。

![图片](https://cdn.xiaolincoding.com//mysql/other/4d850bfe8d712d3d67ff13e59b919452.png)



## 增量复制

如果主从服务器的网络连接断开一段时间，又恢复正常，需要继续保证主从服务器的数据一致性。

主从服务器会采用**增量复制**的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。

<img src="https://cdn.xiaolincoding.com//mysql/other/e081b470870daeb763062bb873a4477e.png" alt="图片" style="zoom:67%;" />

> 主服务器怎么知道要将哪些增量数据发送给从服务器呢？

- **repl_backlog_buffer**，是一个**「环形」**缓冲区，用于主从服务器断连后，从中找到差异的数据；
- **replication offset**，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。

在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。

网络恢复后，从服务器通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：

- 如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用**增量同步**的方式；
- 相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用**全量同步**的方式。

**为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些**，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。



# 哨兵

哨兵机制实现**主从节点故障转移**。

哨兵是一个运行在特殊模式下的Redis进程，哨兵节点主要负责三件事情：**监控、选主、通知**。



## 如何判断主节点真的故障了？

哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。

如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「主观下线」。

> 主观下线与客观下线

哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成**哨兵集群（最少需要三台机器来部署哨兵集群），通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况**。

当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。

当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。



## 由哪个哨兵进行主从故障转移？

需要在哨兵集群中选出一个leader，让leader来执行主从切换。

哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。

> 候选者如何选举成为 Leader？

候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。每个哨兵有一票，候选者将票投给自己，普通哨兵节点投给候选者。

那么在投票过程中，任何一个「候选者」，要满足两个条件：

- 第一，拿到半数以上的赞成票；
- 第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。



## 主从故障转移的过程是怎样的？

1. 选出新主节点

   将网络状态不好的从节点过滤掉，将已经下线的从节点过滤掉。

   然后对剩下的节点进行考察：

   - 第一轮考察：优先级最高（服务器配置好）的从节点胜出
   - 第二轮考察：复制进度最靠前的从节点胜出
   - 第三轮考察：ID号小的从节点胜出

   在选举出从节点后，哨兵 leader 向被选中的从节点发送 `SLAVEOF no one` 命令，让这个从节点解除从节点的身份，将其变为新主节点。

2. 将从节点指向新主节点

   向「从节点」发送 `SLAVEOF` 命令，让它们成为新主节点的从节点。

3. 通知客户的主节点已更换

   通过 Redis 的发布者/订阅者机制，将新主节点的信息通知给客户端。

4. 将旧主节点变为从节点

   继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 SLAVEOF 命令，让它成为新主节点的从节点。



## 哨兵集群是如何组成的？

哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的。

<img src="https://cdn.xiaolincoding.com//picgo/a6286053c6884cf58bf397d01674fe80.png" alt="img" style="zoom: 50%;" />

哨兵会每 10 秒一次的频率向主节点发送 INFO 命令来获取所有「从节点」的信息，和每个从节点建立连接，并在这个连接上持续地对从节点进行监控。