# 缓存

## 缓存雪崩

当**大量缓存数据在同一时间过期（失效）或者`Redis`故障宕机**时，如果此时有大量的请求全部直接访问数据库，从而导致数据库的压力骤增，造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是**缓存雪崩**。

因此，缓存雪崩有两个原因：

- 大量数据同时过期
- Redis 故障宕机

### 大量数据同时过期

应对方法：

1. 均匀设置过期时间

   在对缓存数据设置过期时间时，给这些数据的过期时间加上一个随机数，这样就保证数据不会在同一时间过期。

2. 互斥锁

   当**如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存**（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。

   实现互斥锁的时候，最好设置**超时时间**，防止获取到锁的请求因发生意外阻塞而长时间占有锁。

3. 后台更新缓存

   业务线程不再负责更新缓存，缓存也不设置有效期，而是**让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新**。

   缓存数据不设置有效期，也会在系统内存紧张的时候进行淘汰，可能会发生业务线程读取缓存失效。

   解决上面的问题的方式：

   1. 后台线程不仅负责定时更新缓存，而且也负责**频繁地检测缓存是否有效**，检测到缓存失效就要马上从数据库读取数据，并更新到缓存。
   2. 在业务线程发现缓存数据失效后（缓存数据被淘汰），**通过消息队列发送一条消息通知后台线程更新缓存**。

   在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的**缓存预热**，后台更新缓存的机制刚好也适合干这个事情。




### Redis故障宕机

1. 服务熔断或请求限流机制

   **暂停业务应用对缓存服务的访问，直接返回错误**，等到 Redis 恢复正常后，再允许业务应用访问缓存服务。

   为了减少对业务的影响，我们可以启用**请求限流**机制，**只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务**，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。

2.  构建 Redis 缓存高可靠集群

   通过主从节点的方式构建 Redis 缓存高可靠集群。



## 缓存击穿

如果缓存中的**某个热点数据过期了**，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。

解决方案：

- 互斥锁
- 不给热点数据设置过期时间，由后台更新缓存



## 缓存穿透

当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。

发生情况：

- 业务误操作，缓存中的数据和数据库中的数据都被误删除了
- 黑客恶意攻击，故意大量访问某些读取不存在数据的业务

解决方案：

1. 非法请求的限制

   在API入口处判断请求是否合理

2. 缓存空值或者默认值

   在缓存中设置一个空值或者默认值，请求从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。

3. **使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。**

   在写入数据库数据的时候使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。

   > 布隆过滤器如何工作？

   布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。

   标记操作：

   1. 使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
   2. 将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。
   3. 将每个哈希值在位图数组的对应位置的值设置为 1；

   存在哈希冲突的可能性，如果**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**。

