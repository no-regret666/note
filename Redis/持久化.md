# 持久化

## AOF持久化

### AOF日志

Redis每执行一条写操作命令，就把该命令追加到一个文件中。读操作命令不会被记录。

先执行写操作命令，再追加日志的好处：

1. **避免额外的检查开销**。只有命令语法正确，执行成功后，才会被记录。
2. **不会阻塞当前写操作命令的执行**。

风险：

1. 在将命令写入到磁盘前，服务器宕机了，就会有**丢失数据**的风险。
2. **可能会给「下一个」命令带来阻塞风险**。如果在将日志内容写入到硬盘时，服务器的硬盘的 I/O 压力太大，就会导致写硬盘的速度很慢，进而阻塞住了，也就会导致后续的命令无法执行。

<img src="https://cdn.xiaolincoding.com//mysql/other/28afd536c57a46447ddab0a2062abe84.png" alt="img" style="zoom:67%;" />



### 三种写回策略

<img src="https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img" style="zoom:67%;" />

内核缓冲区的数据什么时候写入到磁盘，由内核决定。

三种写回策略：

![img](https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png)



### AOF重写机制

当AOF文件的大小超过所设定的阈值后，Redis就会启用AOF重写日志，来压缩AOF文件。

AOF重写机制是在重写时，读取当前数据库中所有的键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。这样就减少了AOF文件中的命令数量。

重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去。是因为如果 **AOF 重写过程中失败了，现有的 AOF 文件就会造成污染**，可能无法用于恢复使用。



### AOF后台重写

防止堵塞主线程，**重写AOF过程是由后台子线程bgrewriteaof来完成的**。

- 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；
- 多线程会共享内存，修改共享内存数据的时候需要加锁，这样会降低性能。而使用子进程，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。

主进程正常处理命令，当**修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的。**

这时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，为了解决这个问题，Redis设置了一个 **AOF 重写缓冲区**，在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会**同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」**。

当子进程完成 AOF 重写工作后，会向主进程发送一条信号，主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：

- 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；
- 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。

在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程。



## RDB快照

### 快照怎么用？

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：

- 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会**阻塞主线程**；
- 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**；

Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：

```tex
save 900 1 //900 秒之内，对数据库进行了至少 1 次修改；
save 300 10 //300 秒之内，对数据库进行了至少 10 次修改；
save 60 10000 //60 秒之内，对数据库进行了至少 10000 次修改。
```

Redis的快照是全量快照，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行的频率不能太频繁，否则会影响性能。



### 执行快照时，数据能被修改吗？

执行 bgsave 过程中，Redis 依然可以继续处理操作命令的。**关键的技术就在于写时复制技术（Copy-On-Write, COW）。**

> 写时复制：通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。只有在发生修改内存数据的情况时，物理内存才会被复制一份。
>
> 这样的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。

如果父进程也都是只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。但是如果父进程要修改共享数据里的某一块数据时，就会发生写时复制，这块**数据的物理内存会被复制一份，然后父进程在这个数据副本进行修改操作**。与此同时，**bgsave 子进程可以继续把原来的数据写入到 RDB 文件**。

不过，如果在快照过程中，主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。



### RDB 和 AOF 合体

结合RDB恢复数据快的优点和AOF丢失数据少的优点，将二者结合，**混合使用 AOF 日志和内存快照**，也叫混合持久化。

当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

<img src="https://cdn.xiaolincoding.com//mysql/other/f67379b60d151262753fec3b817b8617.png" alt="图片" style="zoom:50%;" />

前半部分加载速度快，后半部分使得数据更少的丢失。



## Redis 大 Key 对持久化有什么影响？

当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。

AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 fork() 函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程）：

- 创建子进程的过程中，由于要复制父进程的页表等数据结构，阻塞的时间和页表的大小有关，页表越大，阻塞的时间也越长；
- 创建完子进程后，如果父进程修改了共享数据中的大Key,就会发生写时复制，这期间会拷贝物理内存，由于大Key占用的物理内存较大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。



> 大 key 除了会影响持久化之外，还会有以下的影响：

- 客户端阻塞超时。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。
- 引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。
- 阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。
- 内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多。



> 如何避免大 Key 呢？

最好在设计阶段，就把大 key 拆分成一个一个小 key。或者，定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。