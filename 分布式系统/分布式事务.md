# 分布式事务

### 两阶段提交协议（2PC）

- 准备阶段：
  - 协调者向所有参与者发送 REQUEST-TO-PREPARE
  - 当参与者收到REQUEST-TO-PREPARE 消息后, 它向协调者发送消息PREPARED或者NO，表示事务是否准备好；如果发送的是NO，那么事务要回滚；
-  提交阶段：
  - 协调者收集所有参与者的返回消息, 如果所有的参与者都回复的是PREPARED， 那么协调者向所有参与者发送COMMIT 消息；否则，协调者向所有回复PREPARED的参与者发送ABORT消息；
  - 参与者如果回复了PREPARED消息并且收到协调者发来的COMMIT消息，或者它收到ABORT消息，它将执行提交或回滚，并向协调者发送DONE消息以确认。



缺陷：

- **网络抖动导致的数据不一致**：第二阶段中协调者向参与者发送commit命令之后，一旦此时发生网络抖动，导致一部分参与者接收到了commit请求并执行，可其他未接到commit请求的参与者无法执行事务提交。进而导致整个分布式系统出现了数据不一致。
- **超时导致的同步阻塞问题**：2PC中的所有的参与者节点都为事务阻塞型，当某一个参与者节点出现通信超时，其余参与者都会被动阻塞占用资源不能释放。
- **单点故障的风险**：由于严重的依赖协调者，一旦协调者发生故障，而此时参与者还都处于锁定资源的状态，无法完成事务commit操作。虽然协调者出现故障后，会重新选举一个协调者，可无法解决因前一个协调者宕机导致的参与者处于阻塞状态的问题。



### 三阶段提交协议（3PC）

> 在2PC的第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入了超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit,不会一直阻塞等待，解决了2PC的单点故障问题，但3PC还是没能从本质上解决数据一致性的问题。

- CanCommit 阶段：协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。
- PreCommit 阶段：协调者向所有参与者发送PreCommit命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回Yes响应，进入最终commit阶段。一旦参与者中有向协调者发送了No响应，或因网络造成超时，协调者没有接到参与者的响应，协调者向所有参与者发送abort请求，参与者接受abort命令执行事务的中断。
- DoCommit 阶段：在前两个阶段中所有参与者的响应反馈均是YES后，协调者向参与者发送DoCommit命令正式提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送abort请求命令，执行事务的中断。



问题：无法完全避免数据不一致，极端网络情况下可能出现部分提交部分回滚。



### 补偿事务（TCC）

拿下单扣库存解释下它的三个操作：

- Try阶段：下单时通过Try操作去扣除库存预留资源。
- Confirm阶段：确认执行业务操作，在只预留的资源基础上，发起购买请求。
- Cancel阶段：只要涉及到的相关业务中，有一个业务方预留资源未成功，则取消所有业务资源的预留请求。



缺陷：开发成本高，需实现三个方法，要处理异常和补偿逻辑，实现复杂度大。

适用于对性能要求高、业务逻辑复杂的场景，如电商系统订单处理、库存管理。



### Saga事务

将长事务拆分为多个短事务，每个短事务有对应的补偿事务。某个短事务失败，按相反顺序执行补偿事务回滚系统状态。

性能较高，短事务可并行执行减少时间，对业务侵入性小，只需实现补偿事务。

只能保证最终一致性，部分补偿事务失败可能导致系统状态不一致。

适用于业务流程长、对数据一致性要求为最终一致性的场景，如旅游系统订单、航班、酒店预订。



### 可靠消息最终一致性方案

基于消息队列，业务系统执行本地事务时将业务操作封装成消息发至消息队列，下游系统消费消息并执行操作，失败则消息队列重试。

实现简单，对业务代码修改小，系统耦合度低，能保证数据最终一致性。

消息队列可靠性和性能影响大，可能出现消息丢失或延迟，需处理消息幂等性。

适用于对数据一致性要求为最终一致性、系统耦合度低的场景，如电商订单支付、库存扣减。



### 本地消息表

业务与消息存储在同一个数据库，利用本地事务保证一致性，后台任务轮询消息表，通过MQ通知下游服务，下游服务消费成功后确认消息，失败则重试。简单可靠，无外部依赖。消息可能重复消费，需幂等设计。适用场景是异步最终一致性（如订单创建后通知积分服务）。

