# 全局唯一ID实现方案

### 为什么需要全局唯一ID

传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT=1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。

### `UUID`

Universally Unique Identifier，通用唯一识别码，是一组32位数的16进制数字所构成，所以`UUID`总数为16^32=2^128,约等于3.4 * 10^38。

生成的`UUID`是由8-4-4-4-12格式的数据组成，其中32个字符和4个连字符'-'，一般我们使用的时候会将连字符删除`uuid.toString().replaceAll("-","")`

产生方式有5种，每个版本的算法不同，应用范围也不同。

- 基于时间的`UUID`：一般通过当前时间，随机数和本地Mac地址来计算出来。由于使用了MAC地址，因此能够确保唯一性，但是同时也暴露了MAC地址，私密性不够好。
- DCE安全的`UUID`：与基于时间的相同，但会把时间戳的前4位置换为POSIX的UID或GID。
- 基于名字的`UUID`（MD5）：通过计算名字和名字空间的MD5散列值得到。保证了相同名字空间中不同名字生成的`UUID`的唯一性；不同名字空间中的`UUID`的唯一性；相同名字空间中相同名字的`UUID`重复生成是相同的。
- 随机`UUID`：根据随机数，或者伪随机数生成`UUID`，重复可能性忽略不计。
- 基于名字的`UUID`（SHA1）：与第三种相同，只是散列值计算使用SHA1。

#### 缺点

- 不易于存储
- 信息不安全
- 对MySQL索引不利：如果作为数据库主键，`UUID`的无序性可能会引起数据位置频繁变动，严重影响性能。



### 数据库生成

将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定步长，步长的值即为分库的数量或分表的数量。

#### 优点

依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。

#### 缺点

- 强依赖DB，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号
- ID发号性能瓶颈限制在单台MySQL的读写性能



### 使用redis实现

通过提供像`INCR`和`INCRBY`这样的自增原子命令，由于Redis自身的单线程的特点所以能保证生成的ID一定是唯一有序的。

但是单机存在性能瓶颈，无法满足高并发的业务需求，所以可以采用集群的方式来实现。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。

为了避免长期自增后数字过大可以通过与当前时间戳组合起来使用，另外为了保证并发和业务多线程的问题可以采用 Redis + Lua的方式进行编码，保证安全。

Redis 实现分布式全局唯一ID，它的性能比较高，生成的数据是有序的，对排序业务有利，但是同样它依赖于redis，**需要系统引进redis组件，增加了系统的配置复杂性**。



### 雪花算法-Snowflake

以划分命名空间的方式将64-bit位分割成多个部分，每个部分代表不同的含义。

- 第1位占用1bit,其值始终为0,可看作是符号位不使用
- 第2位开始到41位是时间戳
- 中间的10-bit可表示机器数，全部表示机器，可以表示1024台机器；还可以前5位表示机房，后5位表示机房里的机器
- 最后12-bit位是自增序列

这样的划分之后相当于**在一毫秒一个数据中心的一台机器上可产生4096个有序的不重复的ID**。

雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是很高的，而且可以根据自身业务特性分配bit位，非常灵活。

#### 时间回拨问题

服务器上的时间突然倒退回之前的时间。

1. 人为原因，把系统环境的时间改了

2. 有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。

##### 解决方案

1. 直接抛出异常

2. 回拨时间小的时候，不生成ID,循环等待到时间点到达。

3. 上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务；

   或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。但是这个要求我们提前预留出位数，要么从机器id中，要么从序列号中，腾出一定的位，在时间回拨的时候，这个位置 +1。

4. 使用备用机器ID
5. 引入逻辑时钟：在时钟回拨时，维护一个单调递增的逻辑时间戳代表真实时间戳

