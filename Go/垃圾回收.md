# 垃圾回收

回收堆上不再使用的内存，栈上的内存是由编译器自动分配和释放的，不需要GC回收。



### 标记清除算法

- 标记阶段：从根对象开始，查找并标记堆中所有存活的对象

- 清除阶段：遍历堆中所有对象，回收未被标记的对象

回收器在进行标记和清扫的过程中是要暂停整个用户程序的，暂停整个用户程序也称作STW。

如果不STW，可能会出现标记阶段和清除阶段中间发生新的引用，回收器错误删掉还会引用的对象。所以完整的标记清除算法需要在进行GC前进行STW，即暂停整个用户程序。这样的话，性能必然很低，很难有人可以接受这种性能损耗。



### 三色标记法

三色标记法将程序中的对象分为三类：白色、灰色和黑色。

- 白色：未被垃圾收集器访问到的对象，也就是潜在的垃圾对象。在回收开始阶段 ，所有对象都标记为白色；在回收结束后，所有白色对象均不可达，其内存将被释放。
- 灰色：已被垃圾收集器访问到的对象，但是垃圾收集器需要继续扫描它们的子对象，因为其可能存在指向白色对象的外部指针。
- 黑色：已被垃圾收集器访问到的对象，且其引用都已被扫描到，黑色对象中任何一个指针都不可能直接指向白色对象。



标记过程如下：

1. 初始状态：所有对象都是白色的
2. 扫描根对象：从根对象开始扫描，将所有可达对象标记为灰色，并放入待处理集合中
3. 处理灰色对象：从待处理集合中取出灰色对象，将它们引用的对象标记为灰色，并将这些新标记的对象加入待处理集合中，同时将自身标记为黑色。
4. 重复扫描：重复第3步，直到待处理集合为空。此时，所有白色对象都是不可达的垃圾对象，可以进行回收



根节点包含以下几个部分：

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量
2. 执行栈上的对象或指针：每个 goroutine 都包含自己的执行栈，这些执行栈上的对象包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器中的变量：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块



#### 没有STW的三色标记法

从上面的分析来看，在不进行STW时，如果同时满足下面两个条件将会破坏垃圾收集器的正确性：

- 一个白色对象被黑色对象引用(白色对象被挂在黑色对象下)
- 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色对象同时丢失了该白色对象的引用)



### 屏障技术

#### 强弱三色不变性

破坏上述两个垃圾回收器会出现错误回收的两个条件就可以保证对象不会被错误回收。

- 强三色不变性：不存在黑色对象引用到白色对象的指针，即黑色对象不会指向白色对象，只会指向灰色对象或黑色对象
- 弱三色不变性：所有被黑色对象引用的白色对象都处于灰色对象的保护状态，黑色对象可以指向的白色对象，但是必须包含一条从灰色对象到这个白色对象的可达路径

go语言引入内存写屏障技术来实现这两个三色不变性。

1. 插入写屏障
2. 删除写屏障
3. 混合写屏障



#### 插入写屏障

```c
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //step 1
  将新的下游对象ptr标记为灰色   
  
  //step 2
  当前下游对象slot = 新下游对象ptr                    
}
```

插入写屏障一般有两种适用场景：

- A添加新下游对象，比如A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
- A变更下游对象，比如A 将下游对象C 更换为B， B被标记为灰色

> 栈上并没有使用插入写屏障。因为栈空间的特点是容量小，但要求响应速度快，在栈上的对象增加写屏障，会大幅度增加写入指针的额外开销，所以栈空间的对象操作中不使用。而仅仅使用在堆空间对象的操作中。

而对于栈上发生写入操作的情况，会在全部三色标记扫描之后，对栈上重新进行三色标记扫描，但这次为了对象不丢失, 要对本次标记扫描启动STW. 直到栈空间的三色标记结束。



#### 删除写屏障

```c
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //step 1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色){
      标记灰色(当前下游对象slot)     //slot为当前下游对象，即将被删除， 标记为灰色
  }
  
  }  
  //step 2
  当前下游对象slot = 新下游对象ptr
}
```

删除写屏障一般有两种适用场景：

- A删除下游对象，比如A 之前的下游对象B被删除， B被标记为灰色
- A变更下游对象，比如A 将下游对象C 更换为B， C被标记为灰色

删除写屏障虽然不需要在标记结束后开启STW，但却存在回收精度低的问题，可能会有不再被使用的对象最后被标记为了黑色，没有被回收掉，只能通过下一轮GC被回收掉。

不需要在标记结束后开启STW,但是需要在起始阶段开始STW来扫描整个根节点，做一次快照，让所有的可达对象全都在灰色保护下（根对象全为黑，下一级在堆上的对象全灰），之后利用删除写屏障拦截内存写操作，确保弱三色不变式不被破坏，这样就绝对不会有被误回收的对象，就可以保证垃圾回收的正确性。

缺点：

1. 删除写屏障需要在起始阶段执开启STW 扫描，因此不适合具有大栈内存的场景，栈越大，扫描时间越久，比如现代服务器程序栈内存都相对较大，所以都不太适合删除写屏障。
2. 删除写屏障的可能会有遗漏对象需要在下一轮GC才可能被回收，所以税收精度相对较低，不如插入写屏障



#### 混合写屏障

混合写屏障 = 删除写屏障 + 插入写屏障

混合写屏障模式下，利用删除写屏障避免了插入写屏障的STW问题（全部三色标记扫描之后，要STW对栈重新进行三色标记扫描），又利用插入写屏障避免了删除写屏障的STW问题（使用删除写屏障之前需要STW垃圾扫描整个栈空间，获取快照，把所有的堆对象都处于灰色保护中），这样就完美解决了屏障技术带来的STW问题。

混合写屏障的基本思想是：对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。

```c
添加下游对象(当前下游对象slot, 新下游对象ptr) {
//step1 
标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色

//step2 
标记灰色(新下游对象ptr)      //新下游对象标记为灰色

//3step
当前下游对象slot = 新下游对象ptr
}
```

意思就是在垃圾回收阶段，只要是堆上的一个赋值 *slot = ptr 那么都会被拦截住，然后把旧值（*slot）指向的对象，和新值（ptr）指向的对象都置灰（投到扫描队列）

所以混合写屏障的流程可以总结为：

- GC 开始将栈上的对象全部扫描并标记为黑色（注意是一个一个栈标记，不是所有栈全部暂停标记)
- GC 期间，任何在栈上创建的新对象，均标记为黑色
- 被删除的堆对象标记为灰色
- 被添加的堆对象标记为灰色



### GC的触发时机

1. 手动触发：通过调用 runtime.GC() 来触发GC，此调用阻塞式地等待当前GC运行完毕。
2. 被动触发，分为两种方式：
   1. go后台有一系统监控线程，当超过两分钟没有产生任何 GC 时，强制触发 GC。
   2. 使用步调算法，通过内存增长的比例来触发GC，每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC
      - 我们可以通过debug.SetGCPercent(500)来修改步调，这里表示，如果当前堆大小超过了上次标记的堆大小的500%，就会触发
      - 而第一次GC的触发的堆内存临界值是4MB