# 哈希表

<img src="https://pic2.zhimg.com/v2-a8fbef952441e788d882d0656c2cf091_1440w.jpg" alt="img" style="zoom: 50%;" />

在go的map实现中，它的底层结构体是hmap，hmap里维护着若干个bucket数组（即桶数组）

Bucket数组中每个元素都是bmap结构，也即每个bucket（桶）都是bmap结构，每个桶中保存了8个kv对，如果8个慢了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶（溢出桶）。



## 访问原理

```go
v     := map[key]    // 当map中没有对应的key时，会返回value对应类型的零值
v, ok := map[key]    // 当map中没有对应的key时，除了会返回value对应类型的零值,还会返回一个值存不存在的布尔值
```

1. 判断map是否为空或者无数据，若为空或者无数据返回对应的空值
2. map写检测，如果正处于写状态，表示此时不能进行操作，报fatal error
3. 计算出hash值和掩码
4. 判断当前map是否处于扩容状态，如果在扩容执行下面步骤：
   - 根据状态位算判断当前桶是否被迁移
   - 如果迁移，在新桶中查找
   - 未被迁移，在旧桶中查找
   - 根据掩码找到的位置
5. 依次遍历桶以及溢出桶来查找key
   - 遍历桶内的8个槽位
   - 比较该槽位的tophash和当前key的tophash是否相等
     - 相同，继续比较key是否相同，相同则直接返回对应value
     - 不相同，查看这个槽位的状态位是否为"后继空状态"
       - 是，key在以后的槽中也没有，这个key不存在，直接返回零值
       - 否，遍历下一个槽位



## 赋值原理

1. map写检测，如果正处于写状态，表示此时不能进行读取，报fatal error
2. 计算出hash值，将map置为写状态
3. 判断桶数组是否为空，若为空，初始化桶数组
4. 目标桶查找
   1. 根据hash值找到桶的位置
   2. 判断该当前是否处于扩容：
      1. 若正在扩容：迁移这个桶，并且还另外帮忙多迁移一个桶以及它的溢出桶
   3. 获取目标桶的指针，计算出tophash，开始后面的key查找过程
5. key查找
   1. 遍历桶和它的溢出桶的每个槽位，按下述方式查找
   2. 判断槽位的tophash和目标tophash
      1. 不相等
         1. 槽位tophash为空，标记这个位置为侯选位置
         2. 槽位tophash的标志位为"后继空状态"，说明这个key之前没有被插入过，插入key/value
         3. tophash标志位不为空，说明存储着其他key，说明当前槽的tophash不符合，继续遍历下一个槽
      2. 相等
         1. 判断当前槽位的key与目标key是否相等
            1. 不相等，继续遍历下一个槽位
            2. 相等，找到了目标key的位置，原来已存在键值对，则修改key对应的value，然后执行收尾程
6. key插入
   1. 若map中既没有找到key，且根据这个key找到的桶及其这个桶的溢出桶中没有空的槽位了，要申请一个新的溢出桶，在新申请的桶里插入
   2. 否则在找到的位置插入
7. 收尾程序
   1. 再次判断map的写状态
   2. 清除map的写状态



## 扩容

触发扩容情况：

- map的负载因子已经超过6.5（负载因子 = 哈希表中的元素数量 / 桶的数量）

  双倍扩容

- 溢出桶的数量过多

  等量扩容



## 删除原理

删除动作前整体逻辑和前面map的访问差不多，也是map的写检测，以及寻找bucket和key的过程。

如果在找到了目标key，则把当前桶该槽位对应的key和value删除，将该槽位的tophash置为emptyOne，如果发现当前槽位后面没有元素，则将tophash设置为emptyRest，并循环向前检查前一个元素，若前一个元素也为空，槽位状态为emptyOne，则将前一个元素的tophash也设置为emptyRest。这样做的目的是将emptyRest状态尽可能地向前面的槽推进，这样做是为了增加效率，因为在查找的时候发现了emptyRest状态就不用继续往后找了，因为后面没有元素了。



## 遍历

go语言中map的遍历尤其要引起注意，因为每次遍历的数据顺序都是不同的。这是因为go在每次开始遍历前，都会随机选择一个桶下标，一个桶内遍历的起点槽下标，遍历的时候从这个桶开始，在遍历每个桶的时候，都从这个槽下标开始。

go语言为什么要用这种随机开始的位置开始遍历呢？

一方面：因为go的扩容不是一个原子操作，是渐进式的，所以在遍历map的时候，可能发生扩容，一旦发生扩容，key 的位置就发生了重大的变化，下次遍历map的时候结果就不可能按原来的顺序了。

另一方面：hash 表中数据每次插入的位置是变化的，同一个 map 变量内，数据删除再添加的位置也有可能变化，因为在同一个桶及溢出链表中数据的位置不分先后

所以理论上，map的遍历结果就是不同的，所以Go防止用户错误的依赖于每次迭代的顺序，索性每次遍历时，搜是随机选取的一个遍历开始位置。