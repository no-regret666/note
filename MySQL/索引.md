# 索引

索引是数据的目录。

### 索引的分类

- 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
- 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
- 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
- 按「字段个数」分类：单列索引、联合索引。

主键索引和二级索引默认使用的是B+Tree索引。



### B+树

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

![图片](https://cdn.xiaolincoding.com//mysql/other/dd076212a7637b9032c97a615c39dcd7.png)

B+树和B树的性能区别：

#### 1.单点查询

树的高度决定于磁盘I/O操作的次数。

B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

#### 2.插入和删除效率

B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；

#### 3.范围查询

B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。



### `InnoDB`是如何存储数据的

InnoDB 的数据是按「数据页」为单位来读写的， 数据页的默认大小是 16KB。

数据页中的记录按照「主键」顺序组成单向链表。

数据页中有一个页目录，起到记录的索引作用。

![图片](https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png)

1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），**每个槽相当于指针指向了不同组的最后一个记录**。

从图可以看到，**页目录就是由多个槽组成的，槽相当于分组记录的索引**。然后，因为记录是按照「主键值」从小到大排序的，**所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录**，无需从最小记录开始遍历整个页中的记录链表。



### 聚簇索引和二级索引

- 聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；
- 二级索引的叶子节点存放的是主键值，而不是实际数据。

如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。



### 索引失效

- 对索引使用左或者左右模糊匹配，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。
- 对索引使用函数，如 `where length(name) = 6`。
- 对索引进行表达式计算，如 `where id + 1 = 10`。
- 对索引隐式类型转换，MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。
- 联合索引非最左匹配，` (a, b, c)` 联合索引，`where b=2`或`where c=3`这种不从`a`开始匹配的都会失效。
- `where`子句中的`or`，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。



### 哪种count性能最好

结论：

count(*) = count(1) > count(主键字段) > count(字段)

#### count(主键字段)

- 表里只有主键索引，没有二级索引，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。
- 如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。

#### count(1)

- 只有主键索引，没有二级索引，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，但是**不会读取记录中的任何字段的值**。
- 有二级索引时，InnoDB 循环遍历的对象就二级索引了。

#### count(*)

InnoDB以相同的方式处理`SELECT COUNT（\*）`和`SELECT COUNT（1）`操作，没有性能差异。

而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。

#### count(字段)

会采用全表扫描的方式来统计。



#### 优化count(*)

1. 近似值

   使用 show table status 或者 explain 命令来表进行估算。

2. 额外表保存计数值

   将计数值保存到单独的一张计数表中，在新增和删除操作时，我们需要额外维护这个计数表。



### `MySQL`分页优化

`limit offset, size` 和 `limit size` (`limit 0,size`) （前者更慢）

####  基于主键索引的limit执行过程

```mysql
select * from page order by id limit 0, 10;
```

server层会调用innodb的接口，在innodb里的主键索引中获取到第0到10条完整行数据，依次返回给server层，并放到server层的结果集中，返回给客户端。

```mysql
select * from page order by id limit 6000000, 10;
```

server层会调用innodb的接口，由于这次的offset=6000000，会在innodb里的主键索引中获取到第0到（6000000 + 10）条**完整行数据，返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条**，也就是10条数据，放到server层的结果集中，返回给客户端。

可以看出，当当offset非0时，server层会从引擎层获取到**很多无用的数据**，而获取的这些无用数据都是要耗时的。

#### 深度分页问题

```mysql
select * from page;
```

当数据量较大时，这样的sql会超时；

于是我们通过`limit offset size`分页的形式去分批获取，但是当数据表变得很大的时候就会出现**深度分页**问题。

我们可以将所有的数据**根据id主键进行排序**，然后分批次取，将当前批次的最大id作为下次筛选的条件进行查询。

![img](https://cdn.xiaolincoding.com//picgo/318663c9592dc46cf81e3e784e0ebc52.png)

这个操作，可以通过主键索引，每次定位到id在哪，然后往后遍历100个数据，这样不管是多少万的数据，查询性能都很稳定。

必要的时候多去影响产品经理。